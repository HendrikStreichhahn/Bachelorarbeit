%!TEX root = thesis.tex

\chapter{Related work and basics}
\label{chapter-Related-Work}

\section{Runtime Verification}
	Monitoring the AUTOSAR Timing Extensions is the goal of this thesis. As monitoring plays a major role in runtime verification, a short overview of this will be given. The definitions of \cite{RuntimeVerification} are used, in which \emph{Runtime Verification} is a technique that can detect deviations between the run of a system and its formal specification by checking correctness properties. A \emph{run}, which might also be called \emph{trace}, is sequence of the system states, which might be infinite and an \emph{execution} is an finite prefix of this run. A \emph{monitor} reads the trace and decides, whether it fulfills the correctness properties or violates them.\\
	A distinction is made between \emph{offline} and \emph{online} monitoring. Offline monitoring is using a stored trace, that has been recorded before. Therefore, the complete trace (or the complete part of the trace, that should be analyzed) is known in the analysis. Online monitoring checks the properties, while the system is running, which means that the analysis must be done incrementally. Because of memory and time limitations, not all previous states can be read again in online monitoring, more detailed contemplations on the limitations of online monitors will be given in chapter~\ref{chapter-monitorability}.
	%TODO Überleitung!


\section{TeSSLa}

	TeSSLa (\textbf{Te}mporal \textbf{S}tream-based \textbf{S}pecification \textbf{La}nguage) is a functional programming language, build for runtime verification of streams. In TeSSLa, \textbf{streams} are defined as traces of events, each event consists of one data value from a data set $\mathbb D$ and a time value from a time domain $\mathbb T$, which is a \emph{totally ordered semi-ring} $(\mathbb{T}, 0, 1, +, *, \leq)$, that is not negative.


This time domain needs a total order and subsequent timestamps must have increasing time values. A TeSSLa Specification can have several streams with different data sets, but each of these streams must use the same time domain $\mathbb T$, which timestamps are increasing over all streams. Each stream can have only one event per timestamp, but it is possible to have events on different streams at the same timestamp.\\
A distinction between synchronous and asynchronous streams is made. A set of synchronous streams have events in the exact same time stamps, events in asynchronous streams do not have this restriction. It is easy to see, that synchronous streams are a subset of the asynchronous ones, therefore we will only use asynchronous streams from now on.\\
In TeSSLa, calculations are done, when new events are arriving. Based on the specification, output streams are generated with events on the same timestamps as the used input streams, but filtering is possible, where not all input events produce output events. With the \emph{delay}-operator, it is possible to create new timestamps. This possibility will take a large role in this thesis, more on that later.\\
At the timestamps, in which events arrived and calculations are done, you only have direct access to the youngest event of each stream, but with the use of the \emph{last}-operator, which can be used recursively, the event before that can be accessed. The \emph{lift}-operator applies a function, which is defined on data values $\mathbb D$, on each event of one or more streams. Similar to this, the \emph{slift}-operator (signal lift) first applies the given function, when there was at least one event of each input stream. The \emph{time}-operator returns the time value of an event.\\
% TODO formal definition of streams
% TODO \mathbb D bei Daten, aktuell keine Daten und bisher keine Daten
% TODO describe options of monitoring-> online, offline, non-intrusive


\section{Finite Transducers}

%In ~\cite{TeSSLa} werden verschiedene Fragmente von TeSSLa beschrieben, die unterschiedliche Mächtigkeiten haben und äquivalent zu verschiedenen Transduktormodellen sind. Im Fragment \emph{TeSSLa$_{bool}$} sind die Datentypmengen der Ströme auf boolesche Werte beschränkt, als Operatoren sind nur der oben genannte \emph{last}-Operator, der \emph{lift}-Operator