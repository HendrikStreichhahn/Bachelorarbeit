%!TEX root = thesis.tex

\chapter{Monitoring Timing Constraints on possibly infinite Streams}
\label{chapter-monitorability}
	The goal of this paper is to implement an online monitor for TADL2 Timing Constraint on possibly infinite streams. Because of finite system resources, several constraints must be fulfilled, to get correct results in a reasonable time in every case. In this chapter, the term of \emph{Finite Monitorability} will be introduced, which ensures that monitoring a property on infinite streams is possible with finite memory resources and finite time resources per timestamp. As introduction into the setting, some related work will be described, inter alia \emph{TeSSLa}, the programming language which is used for the implementation.

\section{Related Work}

	\subsection{Runtime Verification}
		Monitoring the AUTOSAR Timing Extensions is the goal of this thesis. As monitoring plays a major role in runtime verification, a short overview of this will be given. The definitions of \cite{RuntimeVerification} are used, in which \emph{Runtime Verification} is a technique that can detect deviations between the run of a system and its formal specification by checking correctness properties. A \emph{run}, which might also be called \emph{trace}, is sequence of the system states, which might be infinite and an \emph{execution} is an finite prefix of this run. A \emph{monitor} reads the trace and decides, whether it fulfills the correctness properties or violates them.\\
		A distinction is made between \emph{offline} and \emph{online} monitoring. Offline monitoring is using a stored trace, that has been recorded before. Therefore, the complete trace (or the complete part of the trace, that should be analyzed) is known in the analysis. Online monitoring checks the properties, while the system is running, which means that the analysis must be done incrementally. Because of memory and time limitations, not all previous states can be read again in online monitoring, more detailed contemplations on the limitations of online monitors will be given in chapter~\ref{chapter-monitorability}.
		%TODO Überleitung!
	
	
	\subsection{TeSSLa}
	
		TeSSLa (\textbf{Te}mporal \textbf{S}tream-based \textbf{S}pecification \textbf{La}nguage) is a functional programming language, build for runtime verification of streams. In TeSSLa, \textbf{streams} are defined as traces of events, each event consists of one data value from a data set $\mathbb D$ and a time value from a time domain $\mathbb T$, which is a \emph{totally ordered semi-ring} $(\mathbb{T}, 0, 1, +, *, \leq)$, that is not negative.
		
		
		This time domain needs a total order and subsequent timestamps must have increasing time values. A TeSSLa Specification can have several streams with different data sets, but each of these streams must use the same time domain $\mathbb T$, which timestamps are increasing over all streams. Each stream can have only one event per timestamp, but it is possible to have events on different streams at the same timestamp.\\
		A distinction between synchronous and asynchronous streams is made. A set of synchronous streams have events in the exact same time stamps, events in asynchronous streams do not have this restriction. It is easy to see, that synchronous streams are a subset of the asynchronous ones, therefore we will only use asynchronous streams from now on.\\
		In TeSSLa, calculations are done, when new events are arriving. Based on the specification, output streams are generated with events on the same timestamps as the used input streams, but filtering is possible, where not all input events produce output events. With the \emph{delay}-operator, it is possible to create new timestamps. This possibility will take a large role in this thesis, more on that later.\\
		At the timestamps, in which events arrived and calculations are done, you only have direct access to the youngest event of each stream, but with the use of the \emph{last}-operator, which can be used recursively, the event before that can be accessed. The \emph{lift}-operator applies a function, which is defined on data values $\mathbb D$, on each event of one or more streams. Similar to this, the \emph{slift}-operator (signal lift) first applies the given function, when there was at least one event of each input stream. The \emph{time}-operator returns the time value of an event.\\
		% TODO formal definition of streams
		% TODO \mathbb D bei Daten, aktuell keine Daten und bisher keine Daten
		% TODO describe options of monitoring-> online, offline, non-intrusive
	
	
	\subsection{Finite Transducers}
		
		%In ~\cite{TeSSLa} werden verschiedene Fragmente von TeSSLa beschrieben, die unterschiedliche Mächtigkeiten haben und äquivalent zu verschiedenen Transduktormodellen sind. Im Fragment \emph{TeSSLa$_{bool}$} sind die Datentypmengen der Ströme auf boolesche Werte beschränkt, als Operatoren sind nur der oben genannte \emph{last}-Operator, der \emph{lift}-Operatorde between \emph{offline} and \emph{online} monitoring. Offline monitoring is using a stored trace, that has been recorded before. Therefore, the complete trace (or the complete part of the trace, that should be analyzed) is known in the analysis. Online monitoring checks the properties, while the system is running, which means that the analysis must be done incrementally. Because of memory and time limitations, not all previous states can be read again in online monitoring, more detailed contemplations on the limitations of online monitors will be given in chapter~\ref{chapter-monitorability}.
		%TODO Überleitung!


\section{Finite Monitorability}
	\subsection{Timestamps}
		\label{monitorability_timestamps}
		As we consider streams that can be infinite, the time value of events can also grow into infinity. This is problematic, because it leads to infinite memory and runtime requirements, which cannot be meet, especially not in the context of online monitoring. Therefore, the time domain $\mathbb{T}$ must be restricted by the following constraints:
		\begin{itemize}
			\item
				$\mathbb{T}$ must be discrete.
			\item
				The first used timestamp has the value $t_0=0$
			\item
				All used timestamps must be smaller than $t_{max}$.\\
				$t_{max}$ must be big enough, so it is not reached in practical use \footnote{for example, a 64-bit unsigned integer variable is enough, to cover nanoseconds for 584.55 years}.
			\item
				The distance between two subsequent time values is small enough to observe the wanted constraints.
		\end{itemize}
		%Additionally, a table $\tau \in \mathbb{T}'\times\mathbb{T}$ is defined, where $\mathbb{T}'$ is a set of indices. $\tau$ stores exactly the %timestamps, which are part of the current state of the monitor, which will be introduced in \ref{monitorability_state}. 
	\begin{figure}
		\begin{tikzpicture}
			\node[] (inputRight){$\mathbb{D}_1\times\mathbb{T}, ..., \mathbb{D}_n\times\mathbb{T}$};
			\node[draw, below of=inputRight] (fRight){$f$};
			\node[below of=fRight] (stateRight){$\mathbb{D}_{state}\times\mathbb{T}$};
			\node[draw, below of=stateRight] (delayRight){$Delay$};
			\node[below of=delayRight] (stateDelayRight){$\mathbb{D}_{state}\cup\{timeout\}\times\mathbb{T}$};
			\node[draw, below of=stateDelayRight] (gRight){$g$};
			\node[below of=gRight] (outputRight){$\{true_{until}, false\}\times\mathbb{T}$};
			
			\draw[->] (inputRight) -- (fRight);
			
			\node[right of = stateRight] (ha){};
			\node[right of = fRight] (hb){};
			\draw[->] (ha)  .. controls (hb) .. (fRight);
			
			\draw[->] (fRight) -- (stateRight);
			\draw[->] (stateRight) -- (delayRight);
			\draw[->] (delayRight) -- (stateDelayRight);
			\draw[->] (stateDelayRight) -- (gRight);
			\draw[->] (gRight) -- (outputRight);
			\node [below of=outputRight, align=center] (h0){Finite Monitorability\\with delay};

			
			\node[left of = inputRight] (h1){};
			\node[left of = h1] (h2){};
			\node[left of = h2] (h3){};
			\node[left of = h3] (h4){};
			
			\node[left of = h4] (inputLeft){$\mathbb{D}_1\times\mathbb{T}, ..., \mathbb{D}_n\times\mathbb{T}$};
			\node[draw, below of=inputLeft] (fLeft){$f$};
			\node[below of = fLeft] (h5){};
			\node[below of=h5] (stateLeft){$\mathbb{D}_{state}\times\mathbb{T}$};
			\node[, below of=stateLeft] (delayLeft){};
			\node[draw, below of=delayLeft] (gLeft){$g$};
			\node[below of=gLeft] (outputLeft){$\{true_{until}, false\}\times\mathbb{T}$};
			\draw[->] (inputLeft) -- (fLeft);
			\draw[->] (fLeft) -- (stateLeft);
			\draw[->] (stateLeft) -- (gLeft);
			\draw[->] (gLeft) -- (outputLeft);
			
			\node[left of = stateLeft] (hc){};
			\node[left of = fLeft] (hd){};
			\draw[->] (hc)  .. controls (hd) .. (fLeft);
			
			\node [below of=outputLeft] {Finite Monitorability};
		\end{tikzpicture}
		\centering
		\caption{Overview Finite Monitorability - with or without \emph{delay}}
		\label{fig:OverviewMonitorability}
	\end{figure}
	\subsection{Finite Monitorability}
		%TODO mention figure
		For the definitions of streams and functions defined on them, TeSSLa-like syntax is used. Also, some standard TeSSLa functions are used in the definitions. 
		\subsubsection{Input Streams}
			Let $S_1, S_2, ..., S_n$ be input streams with\\
			$\forall i:$ $S_i=(\mathbb{T}\cdot \mathbb{D}_i)^\omega\cup(\mathbb{T}\cdot \mathbb{D}_i)^+\cup(\mathbb{T}\cdot \mathbb{D}_i)^*\cdot(\mathbb{T}_\infty\cup\mathbb{T}\cdot\{\bot\})$ and\\
			All types $D_i$ have a finite size.
		\subsubsection{State Stream}
			\label{monitorability_state}
			Let $S_{state}$ with\\
			$S_{state}= (\mathbb{T}\cdot \mathbb{D}_{state})^+\cup(\mathbb{T}\cdot \mathbb{D}_{state})^*$\\
			be a state stream, where $\mathbb{D}_{state}$ has a finite size.\\
			Further let $f: S_1 \times S_2 \times ... \times S_n \times S_{state}\rightarrow S_{state}\times \mathbb{T}$ a state transition function, which defines the state stream in an incremental fashion:\\
			$\forall t\in \mathbb T \exists i\in \{1,2,...,n\}: S_i(t)\in\mathbb D_i$\\
			$\rightarrow S_{state}(t)= f(S_1(t), S_2(t), ..., S_n(t), last(S_{state}, merge(S_1, S_2, ..., S_n))(t))$\\
			The runtime of $f$ is in $\mathcal{O}(1)$.
		\subsubsection{Output Stream}
			Let $S_{output}= (\mathbb{T}\cdot \{true_{until}, false\})^+\cup(\mathbb{T}\cdot \{true_{until}, false\})^*$\\
			be the output stream, which is defined via a function\\
			$g: \mathbb{D}_{state}\times \mathbb{T}\rightarrow \{true_{until}, false\}\times \mathbb{T}$\\
			The runtime of $g$ is in $\mathcal{O}(1)$.
		\subsubsection{Evaluation}
			A property of a set of streams is called \emph{Finite Monitorable}, if a function $f$ with type $\mathbb{D}_{state}$ and a function $g$ exist, which fulfill the characteristics called above, and which outputs $true_{until}$, as long as the property is fulfilled and $false$, in any other case. It should be noted that these definitions are \emph{timestamp conservative}, because the streams $S_{state}$ and $S_{output}$ can only change their data value at the timestamps of input events.
		% TODO transducer
		\subsubsection{Equivalences}
			
	\subsection{Finite Monitorability with Delay}
		%TODO mention figure
		Not all of the TADL2 constraints can be monitored in a \emph{timestamp conservative}. For example, the \emph{RepeatConstraint} with the attributes $lower=upper=4$ and $span=1$ expects subsequent events to have a time distance of $4$. If one event is missing, the output of a timestamp conservative monitor would still be $true_{until}$, until the next input event arrives. Therefore, the monitor cannot not check the constraint correctly. Because of this problem, the definition of \emph{Finite Monitorability} is expanded by the ability of introducing new timestamps. To ensure the finiteness of the monitor, only one new timestamp can be introduced, more on that in \ref{DelayGenerator}.
		\subsubsection{Input Streams}
			The definition of the input streams are unchanged.
		\subsubsection{State Stream}
			The function $f$ remains unchanged, but the state stream $S_{state}$ is expanded by an \emph{timeout} value, which is inserted after a specific period of time, in which no input event has arrived.
		\subsubsection{Delay}
			\label{DelayGenerator}
			A \emph{Delay Generator} is inserted into the definition. It has two tasks, first it copies each input it gets from the state transition function $f$ to its output. At the timestamp where an input is copied, a timer, which length depends on the state of the monitor, is started. If the next input comes before the timer runs out, the timer is resetted and started again. If the timer runs out, the Delay Generator outputs the $timeout$ signal, which is repeated at every following input. After the timer has run out once, it is not started again. 
		\subsubsection{Output Stream}
			The output function $g$ is expanded by the \emph{timeout} value:\\
			$g: (\mathbb{D}_{state}\cup\{timeout\})\times \mathbb{T}\rightarrow \{true_{until}, false\}\times \mathbb{T}$\\
			The definition of the output stream $S_{output}$ remains unchanged.
		\subsubsection{Evaluation}
			A property of a set of streams is called \emph{Finite Monitorable with Delay}, if a function $f$ with type $\mathbb{D}_{state}$, a delay generator and a function $g$ exist, which fulfill the characteristics called above, and which outputs $true_{until}$, as long as the property is fulfilled and $false$, in any other case.
			
	\subsection{Non-Finite Monitorability}
		Not all TADL2 constraints are finite monitorable, because a monitor would require infinite memory and/or time resources. In a theoretical view, this makes online monitoring on infinite traces impossible, because a machine with infinite resources does not exist in the real world. In a practical view, many of these problems are solved by using a system with finite memory, with the hope that this finite resources would be enough, to cover the inputs of the ''real world''. In these cases, a distinction is useful, as some constraints have resource requirements, that grow continuously with every input event. These constraints will be called \emph{always Non-Finite Monitorable}. Others constraints only require infinite resources in worst case scenarios, therefore these will be called \emph{worst case Non-Finite Monitorable}. Obviously, the constraints with continuous resource requirement growth cannot be monitored infinitely, but the constraints, that only need infinite resources, can be monitored in many cases.
		%TODO klassifizierung weiter ausführen

	 